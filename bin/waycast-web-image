#!/usr/bin/env --split-string=${JDK_HOME}/bin/java @wayic/Web/imager/java_arguments \c [SS]
package wayic.Web.imager; // [AFN]

// This command runs directly from the present source file, it needs no compiling.

import Breccia.parser.plain.BrecciaCursor;
import Breccia.Web.imager.*;
import Breccia.XML.translator.BrecciaXCursor;
import java.io.IOException;
import java.nio.file.Path;
import Java.Unhandled;
import wayic.Waybrec.parser.WaybrecCursor;

import static Java.Files.emptyDirectory;
import static java.lang.System.err;
import static java.lang.System.exit;
import static java.nio.file.Files.createDirectories;
import static java.nio.file.Files.exists;
import static wayic.Web.imager.Project.outDirectory;


/** A shell command to make a Web image.
  *
  *     @see <a href='http://reluk.ca/project/wayic/Web/imager/bin/waycast-web-image.brec'>
  *       The `waycast-web-image` command</a>
  */
public final class WaycastWebImageCommand { // [AFN]


    private WaycastWebImageCommand( final Path boundaryPath ) { this.boundaryPath = boundaryPath; }



    /** Takes a `waycast-web-image` command from the shell and executes it.
      */
    public static void main( final String[] arguments ) {
        final int p; { // Expected start of positional arguments.
            final int aN = arguments.length;
            if( aN == 1 ) exitOnDemand( arguments[0] );
            p = aN - 1;
            if( p < 0 ) {
                err.println( "waycast-web-image: Too few arguments: " + aN );
                exitWithUsage( 1 ); }}
        final var command = new WaycastWebImageCommand( Path.of(arguments[p]).toAbsolutePath() );
        for( int a = 0; a < p/*argument is nominal, aka an option*/; ++a ) {
            final String arg = arguments[a];
            exitOnDemand( arg );
            String s;
            if( arg.startsWith( s = "--style-sheet=" )) command.styleSheet = arg.substring( s.length() );
            else if( arg.startsWith( s = "--style-sheet-intracast=" )) {
                command.styleSheetIntracast = arg.substring( s.length() ); }
            else {
                err.println( "waycast-web-image: Unrecognized argument: " + arg );
                exit( 1 ); }}
        if( !command.run() ) exit( 1 ); }



////  P r i v a t e  ////////////////////////////////////////////////////////////////////////////////////


    private final Path boundaryPath;



    private static void exitOnDemand( final String arg ) {
        if( arg.equals("-?") || arg.equals("--help") ) exitWithUsage( 0 ); }



    private static void exitWithUsage( final int status ) {
        err.println( "Usage: waycast-web-image [<options>] <boundary path>" );
        err.println( "       waycast-web-image --help | -?" );
        err.println( "Options, one or more of:" );
        err.println( "    --style-sheet=<URI reference>" );
        err.println( "    --style-sheet-intracast=<URI reference>" );
        exit( status ); }



    /** @return True on success, false on failure.
      */
    private boolean run() {
        if( !exists( boundaryPath )) {
            err.println( "waycast-web-image: No such file or directory: " + boundaryPath );
            return false; }
        final Path out;
        try { out = emptyDirectory( createDirectories( outDirectory.resolve( Path.of( "mould" )))); }
        catch( IOException x ) { throw new Unhandled( x ); } // Unexpected for `outDirectory`.
        try( final BrecciaXCursor sourceTranslator = new BrecciaXCursor() ) {
            final var t = new BrecciaHTMLTransformer<>(
              new BrecciaCursor(), sourceTranslator, styleSheet );
            final var tW = new WaybrecHTMLTransformer(
              new WaybrecCursor(), sourceTranslator, styleSheet, styleSheetIntracast, t );
            return Imaging.image( "waycast-web-image", boundaryPath, tW, out ); }}



    String styleSheet = "http://reluk.ca/project/Breccia/Web/imager/image.css";



    String styleSheetIntracast = "http://reluk.ca/project/wayic/Web/imager/intracast_adjunct.css"; }



// NOTES
// ─────
//   AFN  Atypical file naming is allowed here.  ‘The compiler does not enforce the optional restriction
//        defined at the end of JLS §7.6, that a type in a named package should exist in a file whose
//        name is composed from the type name followed by the .java extension.’
//        http://openjdk.java.net/jeps/330
//        https://docs.oracle.com/javase/specs/jls/se15/html/jls-7.html#jls-7.6
//
//   SS · Here the long form `--split-string` (as opposed to `-S`) enables Emacs to recognize this file
//        as Java source code.  See the note apropos of ‘source-launch files encoded with a shebang’ at
//        `http://reluk.ca/project/Java/Emacs/jmt-mode.el`.



                                                   // Copyright © 2020-2022  Michael Allan.  Licence MIT.
